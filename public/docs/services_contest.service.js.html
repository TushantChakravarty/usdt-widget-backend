<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/contest.service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/contest.service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { logger } from "../app.js"
import db from "../models/"
import { Op } from "sequelize";
import { getUserBalance } from "./user.service.js";
const { Contest, GameMode, Sport, MatchCricket, Team, Player, ContestEntryTeam, ContestEntry, Offer, User, Wallet, LeaderBoard, CricketMatch } = db;
import { getSettingByKey } from "../services/site_setting.service.js";
import { SETTINGS_CONSTANTS } from "../constants/settings.constant.js";
/**
 * This service will create an entry .
 * @param {Object} user - Requested user.
 * @param {Object} contest_id - id of contest in which user is getting entry.
 * @param {Object} match_id - internal(autogenerated) id of match in which user is getting entry.
 * @param {Object} team - array of players_id of selected team.
 * @param {Object} captain_id - id of captain of team.
 * @param {Object} vice_captain_id - id of vice captain of team.
 * @returns {Promise&lt;Object>} - A promise that returns success message 
 * @throws {Error} - If there is an error while doing entry in ContestEntry Table.
*/
export async function contestEntrySvc(user, contest_id, match_id, team, captain_id, vice_captain_id) {
    try {
        // 1. Taking user's id 
        const { id } = user.id;
        const currentDateTime = new Date(); // current Date Time
        // 2. finding match with given match_id which should be active,upcoming,and time is not passed.
        let where = {
            id: match_id,
            is_active: true,
            date_start_ist: {
                [Op.gt]: currentDateTime
            },
            status: 1,  // 1 for upcoming match
        }

        const match = await Match.findOne({ where })
        if (!match) throw new Error({ error: "Participation in this match is not allowed." })

        // 3. finding contest with contest_id and should be active
        where = {
            id: contest_id,
            is_active: true,
        }
        const contest = await Contest.findOne({ where })
        if (!contest) throw new Error({ error: "Contest does not exist" })

        // 4. finding all the entries that are performed in this match and contest
        where = {
            match_id,
            contest_id
        }
        const contestEntries = await ContestEntry.findAll({ where })

        // 5. if this contest does not allows, user can take multiple entries in contest then throwing error. 
        if (contest.is_multiple_teams === false) {
            const entry = contestEntries.find(entry => entry.user_id === id)
            if (entry) throw new Error({ error: "You've already participated in this single-entry contest" })
        }

        // TODO: check if multiple_teams === true then how many maximum team that is allowed to take entry.

        // 6. Number of player allwed in team. Ex- if player_number is 9 then team will be of 9 players . If 11 then so.
        const gameMode = await GameMode.findOne({ where: { id: contest?.game_id } })
        if (team.length !== gameMode?.player_number) throw new Error({ error: "Invalid team size" })

        // TODO: Check team(verify team is correct or not)
        // const verify = await checkTeamSvc(team,sport_id) // this checkTeamSvc will return true or false
        // if (!verify) throw new Error({ error: "Invalid team" })

        // checking if slots are available in this contest or not.
        let isSlotsAvailable = contestEntries.length &lt; contest.contest_size ? true : false;
        if (!isSlotsAvailable) throw new Error({ error: "Contest full" })

        // TODO: check balance and bonus and deduct accordingly
        // TODO: make an entry in contestEntryTeam 
        // TODO: make an entry in contestEntry 


    }
    catch (error) {
        logger.error(`contestEntrySvc: ${error}`);
        throw error;
    }
}
/**
 * This service will create an entry of team in contestEntryTeam .
 * @param {Object} user - Requested user.
 * @param {Object} contest_id - id of contest in which user is getting entry.
 * @param {Object} match_id - internal(autogenerated) id of match in which user is getting entry.
 * @param {Object} team - array of players_id of selected team.
 * @returns {Promise&lt;Object>} - A promise that returns success message 
 * @throws {Error} - If there is an error while doing Team entry in ContestEntryTeam Table.
*/

export async function checkTeamSvc(team, sport_id) {
    // try{
    //    const wk_number =  gameMode?.wk_number
    //    const bat_number =  gameMode?.bat_number
    //    const all_rounder_number =  gameMode?.all_rounder_number
    //    const bowl_number =  gameMode?.bowl_number

    //    let wk = []
    //    let bat = []
    //    let all=[]
    //    let bowl = []

    //    let player ;
    //    team.map(async(item) => {
    //     player = await Player.findOne({where : {id : item.id}})
    //     switch(player?.playing_role) {
    //         case "wk": 
    //             wk.push(player)
    //             break;
    //         case "bat": 
    //             bat.push(player)
    //             break;
    //         case "all": 
    //             all.push(player)
    //             break;
    //         case "bowl": 
    //             bowl.push(player)
    //             break;
    //     }


    // })
    // }
    // catch(error){

    // }
}

/**
 * This service will calculate and return PrizePool based on entry fee and spots after deduction of admin commission.
 * @param {number} entryFee - Entry fee.
 * @param {number} spots - number of spots in contest.
    if spots is less than 2 or greater than 20000 then error
    if entryfee is less than 5 or greater than 10000 then error
    if entry fee &lt;= 5 &amp;&amp; spots == 2 then No commition
    if spots &lt;= 5 then 5% commition
    if spots >5 then 10% commition
    prize pool will be round off to nearest whole number 

 * @returns {number} - a number that return prizePool
 * @throws {Error} - If there is an error while calculating prize pool
*/
export async function calPrizePool(entryFee, spots) {
    try {
        if (spots &lt; 2 || spots > 20000 || entryFee &lt; 5 || entryFee > 10000) throw new Error({ error: "Invalid inputs" })
        let commission;
        let prizePool;
        const totalPrize = entryFee * spots;
        if (entryFee &lt;= 5 &amp;&amp; spots === 2) prizePool = totalPrize // No commission
        //if spots &lt;=5 then 5% commission else 10 % commission
        if (spots &lt;= 5) {
            const setting = parseFloat(await getSettingByKey(SETTINGS_CONSTANTS.ADMIN_COMMISSION_TILL_FIVE_SPOTS.key))
            commission = (totalPrize * (setting / 100)) // deduct  commission
        } else {
            const setting = parseFloat(await getSettingByKey(SETTINGS_CONSTANTS.ADMIN_COMMISSION_AFTER_FIVE_SPOTS.key))
            commission = (totalPrize * (setting / 100)) // deduct  commission
        }
        prizePool = Math.round(totalPrize - commission)
        return prizePool;
    } catch (error) {
        logger.error(`calPrizePool: ${error}`);
        throw error;
    }
}



/**
 * Adds a new contestEntry.
 * @controller contest_entry
 * @role admin,user
 * @auth true
 * @route POST /api/v1/contest-entry/
 * @param {Object} request - The request object.
 * @param {Object} reply - The reply object.
 * @throws {Error} If an error occurs while creating the contest_entry.
 */
export async function createContestEntrySvc(match_id, match_type, contest_id, entry_team_id, user) {

    try {
        const current_time = new Date()

        //1. Making a Query so that we can find out the match using match_id where match is active ,status is 1 means it is upcoming and date start is greater than current date
        let where = {
            id: match_id,
            is_active: true,
            status: 1,  // 1 for upcoming match
            date_start_ist: {
                [Op.gt]: current_time
            },
        }

        //2. Finding match
        const match = await CricketMatch.findOne({ where })

        //3. If match doesn't exist we are throwing the error
        if (!match) throw new Error("Match does not exist ")


        const relatedMatches = await CricketMatch.findAll({
            where: {
                [Op.or]: [
                    {
                        [Op.and]: [
                            { [Op.or]: [{ team_id_a: match.team_id_a }, { team_id_b: match.team_id_a }] },
                            { date_end_ist: { [Op.gt]: new Date(), [Op.lt]: match.date_start_ist } }
                        ]
                    },
                    {
                        [Op.and]: [
                            { [Op.or]: [{ team_id_a: match.team_id_b }, { team_id_b: match.team_id_b }] },
                            { date_end_ist: { [Op.gt]: new Date(), [Op.lt]: match.date_start_ist } }
                        ]
                    }
                ],
                id: { [Op.ne]: match_id }
            },
            order: [['date_start_ist', 'DESC']]
        });
        //9. If their is any match exist in upcoming for any of the team then we doesn't allow user to enter in any other matches
        if (relatedMatches.length > 0) throw new Error("Match does not exist ")

        //4. Making a query to check whether entry team exist or not
        where = {
            id: entry_team_id,
            match_id: match_id,
            user_id: user.id
        }

        //5. Finding entry team
        const entry_team = await ContestEntryTeam.findOne({ where })

        //6. If entry_team doesn't exist then we return error
        if (!entry_team) throw new Error("Entry Team does not exist ")

        //7. Making query that to get all the contest which is active and not expired
        const currentDate = new Date().toISOString().split('T')[0];
        if (user.role !== 'admin') {
            where = {
                id: contest_id,
                is_active: true,
                end_date: { [Op.gte]: currentDate },
                start_date: { [Op.lte]: currentDate },
            };
        }
        //8. Finding the contest 
        const contest = await Contest.findOne({ where })
        //9. If contest doesn't exist then we returning the error
        if (!contest) throw new Error("Contest does not exist ")

        // TODO: we apply offer logic here

        // 10.If contest is of multiple teams then user can only participate with the different team if the team is already exist in the contest then we neglect to make the team 
        const contest_entry_exist = await ContestEntry.findOne({ where: { match_id, match_type, contest_id, entry_team_id, user_id: user.id } })
        if (contest_entry_exist &amp;&amp; contest.is_multiple_teams) throw new Error("You cannot participate with the same team again")
        //10. If my contest is free then we directly allow user to participate in the contest by checking the contest is not full and contest multiple teams is allowed or not
        if (contest.contest_type === 'free') {

            //11. Here we taking count of total entries taken to particular contest
            let entry_count = await ContestEntry.count({ where: { match_id, contest_id: contest.id } })

            //12. If my contest is not filled then allow user to pariticipate otherwise we send error in reply 
            if (entry_count &lt; contest.contest_size) {
                // TODO: Here we have to apply that how much multiple teams can user participate
                let team_count = await ContestEntry.count({ where: { match_id, contest_id: contest.id, user_id: user.id } })

                //13. Checking is the contest is of multiple teams if it is then we allowing user to take part in it
                if (contest.is_multiple_teams) {
                    if (contest.multiple_teams_no > team_count) {
                        const contest_entry = await ContestEntry.create({ match_id, match_type, contest_id, user_id: user.id, entry_team_id })
                        return contest_entry
                    }
                    else throw new Error("You already participated with multiple teams")
                }

                //14. If contest is not of multiple teams and we checking here that is user is already participated in the contest . if user is participated then we replying the error
                if (team_count > 0 &amp;&amp; !contest.is_multiple_teams) throw new Error("You already participated")

                //15. if User is not participated in the contest then we allow user to participate and create a contest entry in it
                const contest_entry = await ContestEntry.create({ match_id, match_type, contest_id, user_id: user.id, entry_team_id })
                return contest_entry;
            } else {
                throw new Error("Contest is full")
            }
        }
        //16. We find out user and also include his wallet
        const wallet = await Wallet.findOne({ where: { user_id: user.id } })

        //17. Making a variable to calculate remaining entry fee
        let remain_entry_fee = contest.entry_fee

        //18. Taking a variable where we converting bonus_deduction percentage value into actual value
        let bonus_deduction = (contest.bonus_deduction / 100) * remain_entry_fee


        //19. Making a variable to find out actual balance of the user according to bonus deduction .if bonus deduction is their then we adding the bonus value from the wallet in total balance if not then we not add it 
        let total_balance

        //20. Finding out the total balance
        if (bonus_deduction === 0) {
            total_balance = wallet.balance + wallet.winning
        } else if (wallet.bonus &lt;= bonus_deduction) {
            total_balance = wallet.bonus + wallet.balance + wallet.winning
        } else {
            total_balance = bonus_deduction + wallet.balance + wallet.winning
        }
        //21. If total balance is less than entry fees then we returning the error 
        if (total_balance &lt; contest.entry_fee) throw new Error({ error: 'Insufficient balance', amount: contest.entry_fee - total_balance })

        //22. If bonus deduction is their then we deduct amount from wallet bonus
        if (bonus_deduction !== 0) {
            if (wallet.bonus &lt;= bonus_deduction) {
                remain_entry_fee -= wallet.bonus
                wallet.bonus = 0
            }
            else {
                remain_entry_fee -= bonus_deduction
                wallet.bonus -= bonus_deduction
            }
        }

        //23. If bonus is unable to fulfill the entry fee then we deduct it from wallet balance
        if (remain_entry_fee !== 0) {
            if (wallet.balance &lt;= remain_entry_fee) {
                remain_entry_fee -= wallet.balance
                wallet.balance = 0
            }
            else {
                wallet.balance -= remain_entry_fee
                remain_entry_fee = 0
            }
        }

        //24. If wallet balance is unable to fulfill the entry fee then we deduct it from the wallet winning
        if (remain_entry_fee !== 0) {
            if (wallet.winning &lt;= remain_entry_fee) {
                remain_entry_fee -= wallet.winning
                wallet.winning = 0
            }
            else {
                wallet.winning -= remain_entry_fee
                remain_entry_fee = 0
            }
        }

        // TODO: here we apply payment gateway logic if it will be succcessfull then we do user.wallet.save() 

        //25. Here we taking count of total entries taken to particular contest
        let entry_count = await ContestEntry.count({ where: { match_id: match_id, contest_id: contest.id } })

        //26. If my contest is not filled then allow user to pariticipate otherwise we send error in reply 
        if (entry_count &lt; contest.contest_size) {
            let team_count = await ContestEntry.count({ where: { match_id, contest_id: contest.id, user_id: user.id } })

            //27. Checking is the contest is of multiple teams if it is then we allowing user to take part in it
            if (contest.is_multiple_teams) {
                if (contest.multiple_teams_no > team_count) {
                    const contest_entry = await ContestEntry.create({ match_id, match_type, contest_id, user_id: user.id, entry_team_id })
                    await wallet.save()
                    return contest_entry
                }
                else throw new Error("You already participated with multiple teams")
            }

            //28. If contest is not of multiple teams and we checking here that is user is already participated in the contest . if user is participated then we replying the error

            if (team_count > 0 &amp;&amp; !contest.is_multiple_teams) throw new Error("You already participated")

            //29. if User is not participated in the contest then we allow user to participate and create a contest entry
            const contest_entry = await ContestEntry.create({ match_id, match_type, contest_id, user_id: user.id, entry_team_id })

            await wallet.save()
            return contest_entry
        } else {
            //  TODO:if contest is auto create and contest is full then we provide entry to user in the new contest 
            if (contest.auto_create) {
                const newContest = await Contest.create({
                    category_id: contest.category_id,
                    game_id: contest.game_id,
                    sport_id: contest.sport_id,
                    offer_id: contest.offer_id,
                    leaderboard_id: contest.leaderboard_id,
                    winners_percentage: contest.winners_percentage,
                    name: contest.name,
                    description: contest.description,
                    status: contest.status,
                    is_active: contest.is_active,
                    bonus_deduction: contest.bonus_deduction,
                    contest_type: contest.contest_type,
                    currency_type: contest.currency_type,
                    prize_pool: contest.prize_pool,
                    admin_commission: contest.admin_commission,
                    contest_size: contest.contest_size,
                    entry_fee: contest.entry_fee,
                    confirmed_winning: contest.confirmed_winning,
                    is_multiple_teams: contest.is_multiple_teams,
                    multiple_teams_no: contest.multiple_teams_no,
                    auto_create: contest.auto_create,
                    start_date: contest.start_date,
                    end_date: contest.end_date,
                    visibility: contest.visibility,
                    match_id: match_id,
                    parent_id: contest.parent_id ? contest.parent_id : contest.id,
                    creator_id: contest.creator_id,
                    invite_code: contest.invite_code,
                })

                const contest_entry = await ContestEntry.create({ match_id, match_type, contest_id: newContest.id, user_id: user.id, entry_team_id })
                await wallet.save()
                return contest_entry;


            } else {

                throw new Error("Contest is full")
            }
        }

    } catch (err) {
        logger.error(`contest_entry_service.controller.CreateContestEntrySvc ${err}`);
        throw err
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Admin%252520Routes.html">Admin Routes</a></li><li><a href="module-Analytics%2520Routes.html">Analytics Routes</a></li><li><a href="module-Challenge%2520Routes.html">Challenge Routes</a></li><li><a href="module-Common%2520Validator.html">Common Validator</a></li><li><a href="module-ContestCategory%2520category%2520Routes.html">ContestCategory category Routes</a></li><li><a href="module-Controller.html">Controller</a></li><li><a href="module-CricketMatch%2520Routes.html">CricketMatch Routes</a></li><li><a href="module-CricketPlayer%2520Routes.html">CricketPlayer Routes</a></li><li><a href="module-CricketScorecard%2520Routes.html">CricketScorecard Routes</a></li><li><a href="module-Deposit%2520Routes.html">Deposit Routes</a></li><li><a href="module-Index%2520Routes.html">Index Routes</a></li><li><a href="module-Init%2520Routes.html">Init Routes</a></li><li><a href="module-JWT%2520Authentication%2520Plugin.html">JWT Authentication Plugin</a></li><li><a href="module-Localization%2520Routes.html">Localization Routes</a></li><li><a href="module-Localization%2520Service.html">Localization Service</a></li><li><a href="module-Match%2520Routes.html">Match Routes</a></li><li><a href="module-Media%2520Routes.html">Media Routes</a></li><li><a href="module-Media%2520Service.html">Media Service</a></li><li><a href="module-Offer%2520Routes.html">Offer Routes</a></li><li><a href="module-Offer%2520Service.html">Offer Service</a></li><li><a href="module-Page%252520Routes.html">Page Routes</a></li><li><a href="module-PaymentMethod%2520Routes.html">PaymentMethod Routes</a></li><li><a href="module-Player%2520Routes.html">Player Routes</a></li><li><a href="module-RBAM%2520Plugin.html">RBAM Plugin</a></li><li><a href="module-Redis%2520Cache%2520Plugin.html">Redis Cache Plugin</a></li><li><a href="module-Site%2520Service.html">Site Service</a></li><li><a href="module-Social%2520Routes.html">Social Routes</a></li><li><a href="module-Transaction%2520Routes.html">Transaction Routes</a></li><li><a href="module-User%2520Routes.html">User Routes</a></li><li><a href="module-User%2520Service.html">User Service</a></li><li><a href="module-Validator.html">Validator</a></li><li><a href="module-Withdraw%2520Routes.html">Withdraw Routes</a></li><li><a href="module-config_database.html">config/database</a></li><li><a href="module-contest%2520Routes.html">contest Routes</a></li><li><a href="module-contestEntryTeam%2520Routes.html">contestEntryTeam Routes</a></li><li><a href="module-contest_entry%2520Routes.html">contest_entry Routes</a></li><li><a href="module-game-mode%2520Routes.html">game-mode Routes</a></li><li><a href="module-leaderboard%2520Routes.html">leaderboard Routes</a></li><li><a href="module-models_index.html">models/index</a></li><li><a href="module-sport%2520Routes.html">sport Routes</a></li><li><a href="module-tax%2520Routes.html">tax Routes</a></li><li><a href="module-utils_password.html">utils/password</a></li><li><a href="module-utils_referral.html">utils/referral</a></li><li><a href="utils_cache.module_util.html">util</a></li><li><a href="utils_sms.module_util.html">util</a></li><li><a href="utils_username.module_util.html">util</a></li></ul><h3>Global</h3><ul><li><a href="global.html#GENDERS">GENDERS</a></li><li><a href="global.html#SETTINGS_CONSTANTS">SETTINGS_CONSTANTS</a></li><li><a href="global.html#calPrizePool">calPrizePool</a></li><li><a href="global.html#checkTeamSvc">checkTeamSvc</a></li><li><a href="global.html#contestEntrySvc">contestEntrySvc</a></li><li><a href="global.html#createContestEntrySvc">createContestEntrySvc</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sun Oct 15 2023 18:37:00 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
